/** \file
 *  This C source file was generated by $ANTLR version 3.0.1
 *
 *     -  From the grammar source file : Censor.g
 *     -                            On : 2009-12-03 07:19:11
 *     -                for the parser : CensorParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 * View this file with tabs set to 8 (:set ts=8 in gvim) and indent at 4 (:set sw=4 in gvim)
 *
*/
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "CensorParser.h"
/* ----------------------------------------- */



/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pCensorParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pCensorParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pCensorParser_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always refering to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritence.
 */
/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		INDEX()							INPUT->istream->index(INPUT->istream)
#define	    HASEXCEPTION()					(RECOGNIZER->error == ANTLR3_TRUE)
#define	    EXCEPTION						RECOGNIZER->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    RECOGNIZER->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(INPUT->istream, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						INPUT->istream->consume(INPUT->istream)
#define	    MARK()							INPUT->istream->mark(INPUT->istream)
#define	    REWIND(m)						INPUT->istream->rewind(INPUT->istream, m)
#define	    REWINDLAST()					INPUT->istream->rewindLast(INPUT->istream)
#define		SEEK(n)							INPUT->istream->seek(INPUT->istream, n)
#define	    PERRORRECOVERY					RECOGNIZER->errorRecovery
#define	    _fsp							RECOGNIZER->_fsp
#define	    FAILEDFLAG						RECOGNIZER->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					RECOGNIZER->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
static pANTLR3_UINT8   CensorParserTokenNames[]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "NON_OP_WORD",
        (pANTLR3_UINT8) "SKIP_OP",
        (pANTLR3_UINT8) "MUTE",
        (pANTLR3_UINT8) "DIM",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "FLOAT",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "ROMAN_CHAR",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'/'"
       };


        

/* Forward declare the locally static matching functions we have generated.
 */
static dynamic_array_t *	censorship_file    (pCensorParser ctx);
static censor_edit_section_t *	section    (pCensorParser ctx);
static CensorParser_section_title_return	section_title    (pCensorParser ctx);
static censor_edit_node_t *	censorship_expr    (pCensorParser ctx);
static censor_category_rating_t *	rating_association    (pCensorParser ctx);
static edit_t *	censorship_op    (pCensorParser ctx);
static struct timeval *	time_rule    (pCensorParser ctx);
static dynamic_array_t *	category    (pCensorParser ctx);
static float	rating    (pCensorParser ctx);
static void	CensorParserFree(pCensorParser ctx);

/* Function to initialize bitset APIs
 */
static	void CensorParserLoadFollowSets();

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the gramar file that generated this code
 */
static unsigned char fileName[] = "Censor.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static unsigned char * getGrammarFileName()
{
	return fileName;
}

static pANTLR3_UINT8    *getTokenNames();
/** \brief Create a new CensorParser parser and retrun a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCensorParser
CensorParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
    pCensorParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pCensorParser) ANTLR3_MALLOC(sizeof(CensorParser));
    
    if	(ctx == NULL)
    {
	/* Failed to allocate memory for parser context */
        return  (pCensorParser)ANTLR3_ERR_NOMEM;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We intialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in CensorParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream);
    /* Install the implementation of our CensorParser interface
     */
    ctx->censorship_file	= censorship_file;
    ctx->section	= section;
    ctx->section_title	= section_title;
    ctx->censorship_expr	= censorship_expr;
    ctx->rating_association	= rating_association;
    ctx->censorship_op	= censorship_op;
    ctx->time_rule	= time_rule;
    ctx->category	= category;
    ctx->rating	= rating;

    ctx->free			= CensorParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    
	
    /* Install the token table
     */
    RECOGNIZER->tokenNames   = CensorParserTokenNames;
    
    /* Initialize the follow bit sets
     */
    CensorParserLoadFollowSets();
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
    if (0) {
        freeScope(NULL);
        getTokenNames();
    };
}

/** Free the parser resources
 */
 static void
 CensorParserFree(pCensorParser ctx)
 {
    /* Free any scope memory
     */
    
        
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return CensorParserTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_section_in_censorship_file65  */
static	ANTLR3_BITWORD FOLLOW_section_in_censorship_file65_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000000F0) };
static  ANTLR3_BITSET FOLLOW_section_in_censorship_file65	= { FOLLOW_section_in_censorship_file65_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_censorship_file84  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_censorship_file84_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_EOF_in_censorship_file84	= { FOLLOW_EOF_in_censorship_file84_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_section_title_in_section121  */
static	ANTLR3_BITWORD FOLLOW_section_title_in_section121_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000000E0) };
static  ANTLR3_BITSET FOLLOW_section_title_in_section121	= { FOLLOW_section_title_in_section121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_censorship_expr_in_section156  */
static	ANTLR3_BITWORD FOLLOW_censorship_expr_in_section156_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000000E2) };
static  ANTLR3_BITSET FOLLOW_censorship_expr_in_section156	= { FOLLOW_censorship_expr_in_section156_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NON_OP_WORD_in_section_title184  */
static	ANTLR3_BITWORD FOLLOW_NON_OP_WORD_in_section_title184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004010) };
static  ANTLR3_BITSET FOLLOW_NON_OP_WORD_in_section_title184	= { FOLLOW_NON_OP_WORD_in_section_title184_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_section_title187  */
static	ANTLR3_BITWORD FOLLOW_14_in_section_title187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_14_in_section_title187	= { FOLLOW_14_in_section_title187_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_censorship_op_in_censorship_expr214  */
static	ANTLR3_BITWORD FOLLOW_censorship_op_in_censorship_expr214_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET FOLLOW_censorship_op_in_censorship_expr214	= { FOLLOW_censorship_op_in_censorship_expr214_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_time_rule_in_censorship_expr218  */
static	ANTLR3_BITWORD FOLLOW_time_rule_in_censorship_expr218_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET FOLLOW_time_rule_in_censorship_expr218	= { FOLLOW_time_rule_in_censorship_expr218_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_censorship_expr220  */
static	ANTLR3_BITWORD FOLLOW_15_in_censorship_expr220_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET FOLLOW_15_in_censorship_expr220	= { FOLLOW_15_in_censorship_expr220_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_time_rule_in_censorship_expr224  */
static	ANTLR3_BITWORD FOLLOW_time_rule_in_censorship_expr224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET FOLLOW_time_rule_in_censorship_expr224	= { FOLLOW_time_rule_in_censorship_expr224_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rating_association_in_censorship_expr237  */
static	ANTLR3_BITWORD FOLLOW_rating_association_in_censorship_expr237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET FOLLOW_rating_association_in_censorship_expr237	= { FOLLOW_rating_association_in_censorship_expr237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_category_in_rating_association294  */
static	ANTLR3_BITWORD FOLLOW_category_in_rating_association294_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_category_in_rating_association294	= { FOLLOW_category_in_rating_association294_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_rating_association296  */
static	ANTLR3_BITWORD FOLLOW_14_in_rating_association296_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000300) };
static  ANTLR3_BITSET FOLLOW_14_in_rating_association296	= { FOLLOW_14_in_rating_association296_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rating_in_rating_association300  */
static	ANTLR3_BITWORD FOLLOW_rating_in_rating_association300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_rating_in_rating_association300	= { FOLLOW_rating_in_rating_association300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SKIP_OP_in_censorship_op342  */
static	ANTLR3_BITWORD FOLLOW_SKIP_OP_in_censorship_op342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_SKIP_OP_in_censorship_op342	= { FOLLOW_SKIP_OP_in_censorship_op342_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MUTE_in_censorship_op356  */
static	ANTLR3_BITWORD FOLLOW_MUTE_in_censorship_op356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_MUTE_in_censorship_op356	= { FOLLOW_MUTE_in_censorship_op356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIM_in_censorship_op373  */
static	ANTLR3_BITWORD FOLLOW_DIM_in_censorship_op373_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_DIM_in_censorship_op373	= { FOLLOW_DIM_in_censorship_op373_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_time_rule418  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_time_rule418_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_NUMBER_in_time_rule418	= { FOLLOW_NUMBER_in_time_rule418_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_time_rule420  */
static	ANTLR3_BITWORD FOLLOW_14_in_time_rule420_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET FOLLOW_14_in_time_rule420	= { FOLLOW_14_in_time_rule420_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_time_rule424  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_time_rule424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_NUMBER_in_time_rule424	= { FOLLOW_NUMBER_in_time_rule424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_time_rule426  */
static	ANTLR3_BITWORD FOLLOW_14_in_time_rule426_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000300) };
static  ANTLR3_BITSET FOLLOW_14_in_time_rule426	= { FOLLOW_14_in_time_rule426_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_time_rule430  */
static	ANTLR3_BITWORD FOLLOW_set_in_time_rule430_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_set_in_time_rule430	= { FOLLOW_set_in_time_rule430_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NON_OP_WORD_in_category468  */
static	ANTLR3_BITWORD FOLLOW_NON_OP_WORD_in_category468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET FOLLOW_NON_OP_WORD_in_category468	= { FOLLOW_NON_OP_WORD_in_category468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_16_in_category486  */
static	ANTLR3_BITWORD FOLLOW_16_in_category486_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET FOLLOW_16_in_category486	= { FOLLOW_16_in_category486_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NON_OP_WORD_in_category490  */
static	ANTLR3_BITWORD FOLLOW_NON_OP_WORD_in_category490_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET FOLLOW_NON_OP_WORD_in_category490	= { FOLLOW_NON_OP_WORD_in_category490_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_rating517  */
static	ANTLR3_BITWORD FOLLOW_set_in_rating517_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_set_in_rating517	= { FOLLOW_set_in_rating517_bits, 1	};
     
/** Load up the static bitsets for following set for error recovery.
 *  \remark
 *  These are static after the parser is generated, hence they are static
 *  delcarations in the parser and are thread safe after initialization.
 */
static
void CensorParserLoadFollowSets()
{
    antlr3BitsetSetAPI(&FOLLOW_section_in_censorship_file65);
    antlr3BitsetSetAPI(&FOLLOW_EOF_in_censorship_file84);
    antlr3BitsetSetAPI(&FOLLOW_section_title_in_section121);
    antlr3BitsetSetAPI(&FOLLOW_censorship_expr_in_section156);
    antlr3BitsetSetAPI(&FOLLOW_NON_OP_WORD_in_section_title184);
    antlr3BitsetSetAPI(&FOLLOW_14_in_section_title187);
    antlr3BitsetSetAPI(&FOLLOW_censorship_op_in_censorship_expr214);
    antlr3BitsetSetAPI(&FOLLOW_time_rule_in_censorship_expr218);
    antlr3BitsetSetAPI(&FOLLOW_15_in_censorship_expr220);
    antlr3BitsetSetAPI(&FOLLOW_time_rule_in_censorship_expr224);
    antlr3BitsetSetAPI(&FOLLOW_rating_association_in_censorship_expr237);
    antlr3BitsetSetAPI(&FOLLOW_category_in_rating_association294);
    antlr3BitsetSetAPI(&FOLLOW_14_in_rating_association296);
    antlr3BitsetSetAPI(&FOLLOW_rating_in_rating_association300);
    antlr3BitsetSetAPI(&FOLLOW_SKIP_OP_in_censorship_op342);
    antlr3BitsetSetAPI(&FOLLOW_MUTE_in_censorship_op356);
    antlr3BitsetSetAPI(&FOLLOW_DIM_in_censorship_op373);
    antlr3BitsetSetAPI(&FOLLOW_NUMBER_in_time_rule418);
    antlr3BitsetSetAPI(&FOLLOW_14_in_time_rule420);
    antlr3BitsetSetAPI(&FOLLOW_NUMBER_in_time_rule424);
    antlr3BitsetSetAPI(&FOLLOW_14_in_time_rule426);
    antlr3BitsetSetAPI(&FOLLOW_set_in_time_rule430);
    antlr3BitsetSetAPI(&FOLLOW_NON_OP_WORD_in_category468);
    antlr3BitsetSetAPI(&FOLLOW_16_in_category486);
    antlr3BitsetSetAPI(&FOLLOW_NON_OP_WORD_in_category490);
    antlr3BitsetSetAPI(&FOLLOW_set_in_rating517);

    return;
}

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start censorship_file
 * Censor.g:13:1: censorship_file returns [ dynamic_array_t *p_sections ] : (s= section )+ EOF ;
 */
static dynamic_array_t *
censorship_file(pCensorParser ctx)
{   
    dynamic_array_t * p_sections = NULL;

    censor_edit_section_t * s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s censor_edit_section_t *

    /* Initialize rule variables
     */


     p_sections = new_dynamic_array(8); 
    s = NULL;

    {
        // Censor.g:14:50: ( (s= section )+ EOF )
        // Censor.g:15:5: (s= section )+ EOF
        {
            // Censor.g:15:5: (s= section )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA1_0 = LA(1);
            	    if ( (((LA1_0 >= NON_OP_WORD) && (LA1_0 <= DIM))) ) 
            	    {
            	        alt1=1;
            	    }

            	}
            	switch (alt1) 
            	{
            	    case 1:
            	        // Censor.g:16:9: s= section
            	        {
            	            FOLLOWPUSH(FOLLOW_section_in_censorship_file65);
            	            s=section(ctx);
            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecensorship_fileEx;
            	            }

            	            {

            	                            dynamic_array_append(p_sections,s);
            	                        
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


            		goto rulecensorship_fileEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }
            MATCHT(EOF, &FOLLOW_EOF_in_censorship_file84); 


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecensorship_fileEx; /* Prevent compiler warnings */
    rulecensorship_fileEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return p_sections;
}
/* $ANTLR end censorship_file */

/** 
 * $ANTLR start section
 * Censor.g:22:1: section returns [ censor_edit_section_t *p_section] : (s= section_title )? (c= censorship_expr )+ ;
 */
static censor_edit_section_t *
section(pCensorParser ctx)
{   
    censor_edit_section_t * p_section = NULL;

    CensorParser_section_title_return s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s CensorParser_section_title_return

    censor_edit_node_t * c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c censor_edit_node_t *

    /* Initialize rule variables
     */


     p_section = censor_edit_section_new(); 

    c = NULL;

    {
        // Censor.g:23:54: ( (s= section_title )? (c= censorship_expr )+ )
        // Censor.g:24:5: (s= section_title )? (c= censorship_expr )+
        {

            // Censor.g:24:5: (s= section_title )?
            {
                int alt2=2;
                {
                    int LA2_0 = LA(1);
                    if ( (LA2_0 == NON_OP_WORD) ) 
                    {
                        alt2=1;
                    }
                }
                switch (alt2) 
                {
            	case 1:
            	    // Censor.g:25:9: s= section_title
            	    {
            	        FOLLOWPUSH(FOLLOW_section_title_in_section121);
            	        s=section_title(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesectionEx;
            	        }

            	        {

            	                        p_section->psz_section_title = STRSTREAM->toStringTT(STRSTREAM, s.start, s.stop)->chars;
            	                    
            	        }

            	    }
            	    break;

                }
            }
            // Censor.g:30:5: (c= censorship_expr )+
            {
                int cnt3=0;

                for (;;)
                {
                    int alt3=2;
            	switch ( LA(1) ) 
            	{
            	case SKIP_OP:
            		{
            			alt3=1;
            		}
            	    break;
            	case MUTE:
            		{
            			alt3=1;
            		}
            	    break;
            	case DIM:
            		{
            			alt3=1;
            		}
            	    break;

            	}

            	switch (alt3) 
            	{
            	    case 1:
            	        // Censor.g:31:9: c= censorship_expr
            	        {
            	            FOLLOWPUSH(FOLLOW_censorship_expr_in_section156);
            	            c=censorship_expr(ctx);
            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesectionEx;
            	            }

            	            {

            	                            dynamic_array_append(p_section->p_edits,c);
            	                        
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt3 >= 1 )
            		{
            		    goto loop3;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


            		goto rulesectionEx;
            	}
            	cnt3++;
                }
                loop3: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesectionEx; /* Prevent compiler warnings */
    rulesectionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return p_section;
}
/* $ANTLR end section */

/** 
 * $ANTLR start section_title
 * Censor.g:37:1: section_title : ( NON_OP_WORD )+ ':' ;
 */
static CensorParser_section_title_return
section_title(pCensorParser ctx)
{   
    CensorParser_section_title_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1);

    {
        // Censor.g:37:14: ( ( NON_OP_WORD )+ ':' )
        // Censor.g:38:5: ( NON_OP_WORD )+ ':'
        {
            // Censor.g:38:5: ( NON_OP_WORD )+
            {
                int cnt4=0;

                for (;;)
                {
                    int alt4=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA4_0 = LA(1);
            	    if ( (LA4_0 == NON_OP_WORD) ) 
            	    {
            	        alt4=1;
            	    }

            	}
            	switch (alt4) 
            	{
            	    case 1:
            	        // Censor.g:38:5: NON_OP_WORD
            	        {
            	            MATCHT(NON_OP_WORD, &FOLLOW_NON_OP_WORD_in_section_title184); 


            	        }
            	        break;

            	    default:
            	    
            		if ( cnt4 >= 1 )
            		{
            		    goto loop4;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


            		goto rulesection_titleEx;
            	}
            	cnt4++;
                }
                loop4: ;	/* Jump to here if this rule does not match */
            }
            MATCHT(14, &FOLLOW_14_in_section_title187); 


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesection_titleEx; /* Prevent compiler warnings */
    rulesection_titleEx: ;
    retval.stop = LT(-1);

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return retval;
}
/* $ANTLR end section_title */

/** 
 * $ANTLR start censorship_expr
 * Censor.g:40:1: censorship_expr returns [ censor_edit_node_t *p_censor_edit_node] : p_edit= censorship_op start_time= time_rule '-' end_time= time_rule (ra= rating_association )* ;
 */
static censor_edit_node_t *
censorship_expr(pCensorParser ctx)
{   
    censor_edit_node_t * p_censor_edit_node = NULL;

    edit_t * p_edit;
    #undef	RETURN_TYPE_p_edit
    #define	RETURN_TYPE_p_edit edit_t *

    struct timeval * start_time;
    #undef	RETURN_TYPE_start_time
    #define	RETURN_TYPE_start_time struct timeval *

    struct timeval * end_time;
    #undef	RETURN_TYPE_end_time
    #define	RETURN_TYPE_end_time struct timeval *

    censor_category_rating_t * ra;
    #undef	RETURN_TYPE_ra
    #define	RETURN_TYPE_ra censor_category_rating_t *

    /* Initialize rule variables
     */


     p_censor_edit_node = censor_edit_node_new(); 
    p_edit = NULL;
    start_time = NULL;
    end_time = NULL;
    ra = NULL;

    {
        // Censor.g:41:60: (p_edit= censorship_op start_time= time_rule '-' end_time= time_rule (ra= rating_association )* )
        // Censor.g:42:5: p_edit= censorship_op start_time= time_rule '-' end_time= time_rule (ra= rating_association )*
        {
            FOLLOWPUSH(FOLLOW_censorship_op_in_censorship_expr214);
            p_edit=censorship_op(ctx);
            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecensorship_exprEx;
            }

            FOLLOWPUSH(FOLLOW_time_rule_in_censorship_expr218);
            start_time=time_rule(ctx);
            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecensorship_exprEx;
            }

            MATCHT(15, &FOLLOW_15_in_censorship_expr220); 

            FOLLOWPUSH(FOLLOW_time_rule_in_censorship_expr224);
            end_time=time_rule(ctx);
            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecensorship_exprEx;
            }


            // Censor.g:43:9: (ra= rating_association )*

            for (;;)
            {
                int alt5=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA5_0 = LA(1);
                    if ( (LA5_0 == NON_OP_WORD) ) 
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA5_2 = LA(2);
                            if ( (LA5_2 == 14) ) 
                            {
                                {
                                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                    */
                                    int LA5_3 = LA(3);
                                    if ( (((LA5_3 >= NUMBER) && (LA5_3 <= FLOAT))) ) 
                                    {
                                        alt5=1;
                                    }

                                }
                            }
                            else if ( (LA5_2 == 16) ) 
                            {
                                alt5=1;
                            }

                        }
                    }

                }
                switch (alt5) 
                {
            	case 1:
            	    // Censor.g:43:10: ra= rating_association
            	    {
            	        FOLLOWPUSH(FOLLOW_rating_association_in_censorship_expr237);
            	        ra=rating_association(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecensorship_exprEx;
            	        }

            	        {

            	                        dynamic_array_append(p_censor_edit_node->p_category_ratings,ra);
            	                    
            	        }

            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */

            {

                        p_censor_edit_node->edit = *p_edit;
                        p_censor_edit_node->p_start_time = start_time;
                        p_censor_edit_node->p_end_time   = end_time;
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecensorship_exprEx; /* Prevent compiler warnings */
    rulecensorship_exprEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return p_censor_edit_node;
}
/* $ANTLR end censorship_expr */

/** 
 * $ANTLR start rating_association
 * Censor.g:54:1: rating_association returns [censor_category_rating_t *p_rating] : (c= category ':' r= rating ) ;
 */
static censor_category_rating_t *
rating_association(pCensorParser ctx)
{   
    censor_category_rating_t * p_rating = NULL;

    dynamic_array_t * c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c dynamic_array_t *

    float r;
    #undef	RETURN_TYPE_r
    #define	RETURN_TYPE_r float

    /* Initialize rule variables
     */


     p_rating = malloc(sizeof(*p_rating)); 
    c = NULL;
    r = 0.0;

    {
        // Censor.g:55:53: ( (c= category ':' r= rating ) )
        // Censor.g:56:5: (c= category ':' r= rating )
        {
            // Censor.g:56:5: (c= category ':' r= rating )
            // Censor.g:56:7: c= category ':' r= rating
            {
                FOLLOWPUSH(FOLLOW_category_in_rating_association294);
                c=category(ctx);
                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulerating_associationEx;
                }

                MATCHT(14, &FOLLOW_14_in_rating_association296); 

                FOLLOWPUSH(FOLLOW_rating_in_rating_association300);
                r=rating(ctx);
                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulerating_associationEx;
                }


            }

            {

                        p_rating->rating = r;
                        p_rating->p_category_hierarchy = c;
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerating_associationEx; /* Prevent compiler warnings */
    rulerating_associationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return p_rating;
}
/* $ANTLR end rating_association */

/** 
 * $ANTLR start censorship_op
 * Censor.g:62:1: censorship_op returns [ edit_t *p_edit] : ( SKIP_OP | MUTE | DIM ) ;
 */
static edit_t *
censorship_op(pCensorParser ctx)
{   
    edit_t * p_edit = NULL;

    /* Initialize rule variables
     */


     p_edit= malloc(sizeof(*p_edit)); 
    {
        // Censor.g:63:51: ( ( SKIP_OP | MUTE | DIM ) )
        // Censor.g:64:5: ( SKIP_OP | MUTE | DIM )
        {

            // Censor.g:64:5: ( SKIP_OP | MUTE | DIM )
            {
                int alt6=3;
                switch ( LA(1) ) 
                {
                case SKIP_OP:
                	{
                		alt6=1;
                	}
                    break;
                case MUTE:
                	{
                		alt6=2;
                	}
                    break;
                case DIM:
                	{
                		alt6=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "64:5: ( SKIP_OP | MUTE | DIM )";
                    EXCEPTION->decisionNum  = 6;
                    EXCEPTION->state        = 0;


                    goto rulecensorship_opEx;
                }

                switch (alt6) 
                {
            	case 1:
            	    // Censor.g:65:9: SKIP_OP
            	    {
            	        MATCHT(SKIP_OP, &FOLLOW_SKIP_OP_in_censorship_op342); 

            	        {
            	            *p_edit=SKIP_OP;
            	        }

            	    }
            	    break;
            	case 2:
            	    // Censor.g:66:9: MUTE
            	    {
            	        MATCHT(MUTE, &FOLLOW_MUTE_in_censorship_op356); 

            	        {
            	            *p_edit=MUTE;   
            	        }

            	    }
            	    break;
            	case 3:
            	    // Censor.g:67:9: DIM
            	    {
            	        MATCHT(DIM, &FOLLOW_DIM_in_censorship_op373); 

            	        {
            	            *p_edit=DIM;    
            	        }

            	    }
            	    break;

                }
            }
            {
                 printf("edit %d\n",*p_edit); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecensorship_opEx; /* Prevent compiler warnings */
    rulecensorship_opEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return p_edit;
}
/* $ANTLR end censorship_op */

/** 
 * $ANTLR start time_rule
 * Censor.g:71:1: time_rule returns [ struct timeval *p_time] : hour= NUMBER ':' minute= NUMBER ':' second= ( FLOAT | NUMBER ) ;
 */
static struct timeval *
time_rule(pCensorParser ctx)
{   
    struct timeval * p_time = NULL;

    pANTLR3_COMMON_TOKEN    hour;
    pANTLR3_COMMON_TOKEN    minute;
    pANTLR3_COMMON_TOKEN    second;

    /* Initialize rule variables
     */


     p_time= malloc(sizeof(*p_time)); 
    hour       = NULL;
    minute       = NULL;
    second       = NULL;

    {
        // Censor.g:72:51: (hour= NUMBER ':' minute= NUMBER ':' second= ( FLOAT | NUMBER ) )
        // Censor.g:73:5: hour= NUMBER ':' minute= NUMBER ':' second= ( FLOAT | NUMBER )
        {
            hour = (pANTLR3_COMMON_TOKEN)LT(1);
            MATCHT(NUMBER, &FOLLOW_NUMBER_in_time_rule418); 

            MATCHT(14, &FOLLOW_14_in_time_rule420); 

            minute = (pANTLR3_COMMON_TOKEN)LT(1);
            MATCHT(NUMBER, &FOLLOW_NUMBER_in_time_rule424); 

            MATCHT(14, &FOLLOW_14_in_time_rule426); 

            second=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= NUMBER) && (LA(1) <= FLOAT)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_time_rule430;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_time_rule430);    goto ruletime_ruleEx;
            }

            {

                        printf("hour = %s\n",hour->getText(hour)->chars);
                        printf("minute = %s\n",minute->getText(minute)->chars);
                        printf("second = %s\n",second->getText(second)->chars);
                        printf("p_time= %p\n",p_time);
                        p_time->tv_sec = 60*60*atoi(hour->getText(hour)->chars);
                        p_time->tv_sec += 60*atoi(minute->getText(minute)->chars);
                        float f_seconds = atof(second->getText(second)->chars);
                        p_time->tv_sec += (int)f_seconds;
                        p_time->tv_usec = (int)((f_seconds-((int)f_seconds))*1000);
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletime_ruleEx; /* Prevent compiler warnings */
    ruletime_ruleEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return p_time;
}
/* $ANTLR end time_rule */

/** 
 * $ANTLR start category
 * Censor.g:87:1: category returns [ dynamic_array_t *p_dynamic_array] : nop= NON_OP_WORD ( '/' nop= NON_OP_WORD )* ;
 */
static dynamic_array_t *
category(pCensorParser ctx)
{   
    dynamic_array_t * p_dynamic_array = NULL;

    pANTLR3_COMMON_TOKEN    nop;

    /* Initialize rule variables
     */


     p_dynamic_array = new_dynamic_array(1); 
    nop       = NULL;

    {
        // Censor.g:88:55: (nop= NON_OP_WORD ( '/' nop= NON_OP_WORD )* )
        // Censor.g:89:5: nop= NON_OP_WORD ( '/' nop= NON_OP_WORD )*
        {
            nop = (pANTLR3_COMMON_TOKEN)LT(1);
            MATCHT(NON_OP_WORD, &FOLLOW_NON_OP_WORD_in_category468); 

            {
                 dynamic_array_append(p_dynamic_array, nop->getText(nop)->chars); 
            }

            // Censor.g:90:5: ( '/' nop= NON_OP_WORD )*

            for (;;)
            {
                int alt7=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA7_0 = LA(1);
                    if ( (LA7_0 == 16) ) 
                    {
                        alt7=1;
                    }

                }
                switch (alt7) 
                {
            	case 1:
            	    // Censor.g:91:9: '/' nop= NON_OP_WORD
            	    {
            	        MATCHT(16, &FOLLOW_16_in_category486); 

            	        nop = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(NON_OP_WORD, &FOLLOW_NON_OP_WORD_in_category490); 

            	        {
            	             dynamic_array_append(p_dynamic_array, nop->getText(nop)->chars); 
            	        }

            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecategoryEx; /* Prevent compiler warnings */
    rulecategoryEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return p_dynamic_array;
}
/* $ANTLR end category */

/** 
 * $ANTLR start rating
 * Censor.g:94:1: rating returns [ float the_rating] : r= ( FLOAT | NUMBER ) ;
 */
static float
rating(pCensorParser ctx)
{   
    float the_rating = 0.0;

    pANTLR3_COMMON_TOKEN    r;

    /* Initialize rule variables
     */


    r       = NULL;

    {
        // Censor.g:95:5: (r= ( FLOAT | NUMBER ) )
        // Censor.g:95:7: r= ( FLOAT | NUMBER )
        {
            r=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= NUMBER) && (LA(1) <= FLOAT)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_rating517;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_rating517);    goto ruleratingEx;
            }

            {

                        the_rating = atof(r->getText(r)->chars);
                        if ( the_rating < 0.0  ) { the_rating = 0.0;  };
                        if ( the_rating > 10.0 ) { the_rating = 10.0; };
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleratingEx; /* Prevent compiler warnings */
    ruleratingEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return the_rating;
}
/* $ANTLR end rating */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
